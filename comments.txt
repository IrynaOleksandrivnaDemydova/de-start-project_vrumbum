/*НОВЫЕ КОММЕНТАРИИ от 22 сентября 2024*/

Егор, привет!

Спасибо за оперативную проверку моей первой версии проекта и за все комментарии!
Я не знала, как скачать твою версию с комментариями, поэтому все изменения буду делать в файлах, которые уже отправляла ранее, 
буду писать сверху новый добавочный код. Надеюсь, что так будет понятно. Изменения вроде как зеленым здесь в VS Code
отображаются.  

Кстати, заметила, что файл DataModelProjectBaseSQL.png при загрузке через GitHub при первой отправлке не прошел, 
но, надеюсь, что ты видишь обновленную схему DataModelProjectBaseSQL_New_22.09.2024
в моем профиле playground_start_20240820_84cad96358.

Спасибо за инфо насчет нормализации car_shop.car_specification. У меня была мысль изначально вынести в отдельную 
таблицу страны, и также в отдельную таблицу бренд + модель, т.к. считала, что уникальные сочетания, но в итоге сделала
car_shop.car_specification, т.к. посчитала, что комбинации уникальные. Ок, поняла, что с Германия / Germany могут быть проблемы.

Ок, я вынесла в отдельные таблицы страны, брэнды и модели, а также по рекомендации страны связала с брэндами, а  брэнды с моделями. 
а затем модели с цветами. Также постаралась поправить наполнение готовых таблиц без изменения схемы по твоей рекомендации. 

Также я поправила парсинг модели, теперь видно "Model X" для Tesla, спасибо, что заметил. 

Соответствующие коды доработки указаны в файлах DDL / INSERT, ниже логика действий. 

Шаг 1. Создание таблицы car_shop.country и ее наполнение данными по brand_origin из таблицы raw_data.sales.
(стране NULL я присвоила значение "Unknown" только потому, что когда начала делать шаг в INSERT.sql
/*Наполнение поля country_id таблицы брэндов brand*/, он не хотел брать ID страны с NULL, не джойнил мне его верно. 
Надеюсь, это ок)

Шаг 2. Создание таблицы car_shop.brand и ее наполнение данными brand из таблицы raw_data.sales.

Шаг 3. Создание таблицы моделей model и ее наполнение данными из raw_data.sales.

Шаг 4. Удаление старой таблицы car_specification.

Шаг 5. Удаление старой таблицы car_specification_possible.

Шаг 6. Создание новой таблицы car_specification, со всеми возможными комбинациями model + color.

Шаг 7. Наполнение поля car_id уже существующей таблицы car_shop.sales новыми актуализированными данными.

Шаг 8. Создание связи между car_shop.sales и car_shop.car_specification, добавление CONSTRAINT на поле car_id.

На выходе получилась схема DataModelProjectBaseSQL_New_22.09.2024.png

Также я перепроверила запросы task_1 - task_6 учетом нового сочетания таблиц в схеме car_shop.sales, 
чтобы посмотреть, все ли работает. 

task_1 - обновила код.
task_2 - обновила код.
task_3 - оставила без изменений, код рабочий.
task_4 - обновила код.
task_5 - обновила код.
task_6 - оставила без изменений, код рабочий.

ПОСЛЕДНИЙ ВОПРОС: Егор, ты мне дал рекомендацию при первой проверке, как грузить в финальную таблицу данные из сырых данных
"Смысл примерно следующий, ты джойнишь таблицу сырых данных на справочник, например моделей по условию 
совпадения названия модели из справочника и распаршеное название модели из сырой таблицы и в селекте 
выбираешь айдишник модели из справочника моделей. 
Так ты сможешь заполнить таблицу продаж уже ключевым полем, а не строкой."

Я вроде как поняла, т.к. по этой схеме заполняла в файле INSERT.sql на этих 2-х этапах:
/*Наполнение поля brand_id таблицы моделей model*/
/*Наполнение поля car_id таблицы продаж car_shop.sales*/

Это то, что ты мне рекомендовал, это ты имел ввиду? Надеюсь, я верно реализовала, но я крутила код туда-сюда, 
и смогла написать только через временные таблицы по структуре "WITH ... AS". По результатам вроде как заджойнила верно,
единственное, что меня смутило, что я использовала временные таблицы "WITH ... AS", которые знала еще с прошлого, но 
в теории на этом курсе нам не рассказывали еще про временные таблицы. Надеюсь, что я все-таки сделала верно. 
Если есть еще другой способ, подскажешь, пожалуйста? Заранее спасибо!

Еще раз спасибо за проверку и за обратную связь! :)

/*СТАРЫЕ КОММЕНТАРИИ от 19 сентября 2024*/
/*Добавьте в этот файл пояснения к выбранной модели данных. 
Также вы можете сохранить здесь другие комментарии по проекту, которые вы считаете необходимыми, 
и задать вопросы ревьюеру*/

Добрый день!

Выбранная модель данных представлена в файле DataModelProjectBaseSQL.png.

Создала ее, вынеся в отдельные таблицы повторяющиеся данные:

1) цвет - таблица color.
2) в графе auto повторяются бренд (brand_name), название машины (model_name), а также 
brand_origin и gasoline_consumption (есть в условии, средний по модификациям, и также по проверке сырых данных).
Эти 4 компонента тоже идут вместе и соответствуют каждой машине, поэтому их вынесла в отдельную таблицу car_specification.
3) повторяются данные клиентов (person, phone) -таблица person.

На основе таблицы color и car_specification создала таблицу car_specification_possible, которую заполнила
всеми возможными комбинациями машин и цветов. 

Таблица sales связана с таблицами  car_specification_possible и person. Изначально создавая sales
перенесла все сырые данные туда, а также вставила 2 колонки для внешних ключей связанных таблиц, и заполнила данными. 
Затем удалила таблицы sales столбцы сырых данных которые больше не нужны, а именно:

-- person, phone - нормализованные данные есть в таблице person, а в car_shop.sales остается person_id
-- color - нормализованные данные есть в таблице color и car_specification_possible (color_id)
-- brand, model, brand_origin, gasoline_consumption - нормализованные данные есть в таблице car_specification (id) и car_specification_possible (car_specification_id)

В задании был вопрос ниже, ответ ниже.

* какие поля могут содержать NULL, а где нужно добавить ограничение NOT NULL.
	Могут содержать NULL: gasoline_consumption (отсутствует для электромобилей), а также brand_origin (увидела это после просмотра сырых данных)
	Теоретически можно добавить ограничение NOT NULL: auto, price, date, person, phone, discount, но по факту я добавила 
    NOT NULL только в цену price

/*МОЙ ВОПРОС*/

Это верный ход мысли - при создании таблицы sales вначале заполнить ее всеми сырыми данными и затем на основе них заполнить колонки
с внешними ключами к другим таблицам, и затем только уже удалить ненужные столбцы сырых данных, которые уже есть в нормализованных таблицах?
Либо был какой-то другой альтернативный вариант выполнения задания? Спасибо!